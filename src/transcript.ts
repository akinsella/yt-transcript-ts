import axios, { AxiosInstance } from 'axios';
import { FetchedTranscript } from './fetched-transcript';
import { TranslationLanguage } from './models';
import { CouldNotRetrieveTranscript } from './errors';
import { TranscriptParser } from './transcript-parser';

/**
 * Represents a YouTube transcript that can be fetched or translated.
 */
export class Transcript {
  /** The YouTube video ID this transcript belongs to */
  public readonly videoId: string;

  /** URL to fetch the transcript content from YouTube */
  public readonly url: string;

  /** Full human-readable language name (e.g., "English") */
  public readonly language: string;

  /** Language code (e.g., "en", "en-US", "es") */
  public readonly languageCode: string;

  /** Whether this transcript was automatically generated by YouTube */
  public readonly isGenerated: boolean;

  /** List of languages this transcript can be translated to */
  public readonly translationLanguages: TranslationLanguage[];

  /** Mapping of language codes to language names for available translations */
  public readonly translationLanguagesMap: Map<string, string>;

  constructor(
    videoId: string,
    url: string,
    language: string,
    languageCode: string,
    isGenerated: boolean,
    translationLanguages: TranslationLanguage[]
  ) {
    this.videoId = videoId;
    this.url = url;
    this.language = language;
    this.languageCode = languageCode;
    this.isGenerated = isGenerated;
    this.translationLanguages = translationLanguages;
    
    // Build translation languages map
    this.translationLanguagesMap = new Map();
    for (const lang of translationLanguages) {
      this.translationLanguagesMap.set(lang.languageCode, lang.language);
    }
  }

  /**
   * Fetches the actual transcript content from YouTube.
   * 
   * @param client HTTP client for making requests
   * @param preserveFormatting Whether to preserve HTML formatting in the transcript
   * @returns The fetched transcript
   */
  async fetch(client: AxiosInstance, preserveFormatting: boolean = false): Promise<FetchedTranscript> {
    try {
      const response = await client.get(this.url);
      
      if (response.status !== 200) {
        throw CouldNotRetrieveTranscript.youTubeRequestFailed(
          this.videoId,
          `HTTP ${response.status}: ${response.statusText}`
        );
      }

      const parser = new TranscriptParser(preserveFormatting);
      const snippets = parser.parse(response.data);

      return new FetchedTranscript(
        snippets,
        this.videoId,
        this.language,
        this.languageCode,
        this.isGenerated
      );
    } catch (error) {
      if (error instanceof CouldNotRetrieveTranscript) {
        throw error;
      }
      
      if (axios.isAxiosError(error)) {
        throw CouldNotRetrieveTranscript.youTubeRequestFailed(
          this.videoId,
          `Network error: ${error.message}`
        );
      }
      
      throw CouldNotRetrieveTranscript.youTubeDataUnparsable(this.videoId);
    }
  }

  /**
   * Returns whether this transcript can be translated to other languages.
   */
  isTranslatable(): boolean {
    return this.translationLanguages.length > 0;
  }

  /**
   * Creates a new transcript instance for a specific translation language.
   * 
   * @param languageCode The target language code for translation
   * @returns A new Transcript instance for the translated version
   */
  translate(languageCode: string): Transcript {
    if (!this.isTranslatable()) {
      throw CouldNotRetrieveTranscript.translationUnavailable(
        this.videoId,
        'This transcript cannot be translated'
      );
    }

    const targetLanguage = this.translationLanguagesMap.get(languageCode);
    if (!targetLanguage) {
      const availableLanguages = Array.from(this.translationLanguagesMap.keys()).join(', ');
      throw CouldNotRetrieveTranscript.translationLanguageUnavailable(
        this.videoId,
        `Language '${languageCode}' is not available. Available languages: ${availableLanguages}`
      );
    }

    // Create translation URL by adding the target language parameter
    const url = new URL(this.url);
    url.searchParams.set('tlang', languageCode);

    return new Transcript(
      this.videoId,
      url.toString(),
      targetLanguage,
      languageCode,
      this.isGenerated,
      [] // Translated transcripts cannot be further translated
    );
  }

  /**
   * Translates and fetches the transcript in one operation.
   * 
   * @param client HTTP client for making requests
   * @param languageCode The target language code for translation
   * @param preserveFormatting Whether to preserve HTML formatting
   * @returns The fetched translated transcript
   */
  async translateAndFetch(
    client: AxiosInstance,
    languageCode: string,
    preserveFormatting: boolean = false
  ): Promise<FetchedTranscript> {
    const translatedTranscript = this.translate(languageCode);
    return translatedTranscript.fetch(client, preserveFormatting);
  }

  /**
   * Returns the language name.
   */
  getLanguage(): string {
    return this.language;
  }

  /**
   * Returns the language code.
   */
  getLanguageCode(): string {
    return this.languageCode;
  }

  /**
   * Returns whether this transcript was automatically generated.
   */
  getIsGenerated(): boolean {
    return this.isGenerated;
  }

  /**
   * Returns a string representation of the transcript.
   */
  toString(): string {
    const generatedText = this.isGenerated ? 'Auto' : 'Manually';
    return `${this.language} (${this.languageCode}) - ${generatedText} generated`;
  }

  /**
   * Converts the transcript to JSON format.
   */
  toJSON(): any {
    return {
      videoId: this.videoId,
      url: this.url,
      language: this.language,
      languageCode: this.languageCode,
      isGenerated: this.isGenerated,
      translationLanguages: this.translationLanguages,
    };
  }

  /**
   * Creates a Transcript from JSON data.
   */
  static fromJSON(data: any): Transcript {
    return new Transcript(
      data.videoId || '',
      data.url || '',
      data.language || '',
      data.languageCode || '',
      data.isGenerated || false,
      data.translationLanguages || []
    );
  }
} 